1. Написать скрипт, который удаляет из текстового файла пустые строки и заменяет маленькие символы на большие. Воспользуйтесь tr или SED.
	(предварительно в текущей директории размещен файл который будет использован для редактирования file.txt)
	Создаю файл task1.sh в котором планирую писать скрипт
		touch task1.sh
	Делаю файл исполняемым то есть даю разрешение всем пользователям исполнять данный скрипт
		chmod +x task1.sh
	Редактирую файл (пишу в нем скрип представленный ниже)
		nano task1.sh
	Запускаю скрипт (проверяю работоспособность)
		./task1.sh file.txt out.txt
	если скрипт получит недостаточное количество параметров редактирование не будет произведено.
		./task1.sh file.txt
----------------------------------------------------------------------------------------------------------------------------------------------		
	Разбор скрипта:
*************************************************************
	task1.sh
*************************************************************
		#!/bin/bash
		if [ -z "$2" ]
		then 
			echo no 2 arguments
			echo example: ./transf file_in file_out
			exit 1
		fi
		sed /^$/d "$1" | sed 's/[a-z]/\U&/g' > "$2"
*************************************************************		
	Данный скрипт позволяет производить замену маленьких латинских символов на большие латинские символы. При выполнении скрипта в командной строке передается два параметра: 1 - входящий файл и 2 - файл в который будут записаны отредактированные данные из 1-го файла.
		
	Первым выполняется условие которое проверяет имеется ли после введенной команды 2-ой аргумент
		если 2-ой аргумент имеется то будет выполнена команда расположенная после условия
		ecли 2-ой аргумент отсутствует будет выполнены команды расположенные в условии после then. В частности выводится сообщение  о том что нет второго аргумента и сообщение пример (подсказка) о синткасисе правильного ввода команды. И далее выход (exit 1) из скрипта с сообщением об ошибке с номером 1.
	Если в команде присутствует второй аргумент (если есть второй аргумент, то соответстенно первый тоже будет присутствовать) будет выполнена строка:
		sed /^$/d "$1" | sed 's/[a-z]/\U&/g' > "$2"
			sed /^$/d | sed' "$1" -  первая часть команды удаляет все пустые строки
				/^$/d - удалить все строки которые имеют последовательность начала (^) и конца($) строки (т.е. пустые строки), ключ d непосредственно говорит об удалении строки в которой найдена данная  последовательность
				$1 - поток будет считываться из файла переданного 1 аргументом в командной строке
			| - результат предыдушей команды перенаправляется черeз pipe (|) на вход следующей команды
			sed 's/[a-z]/\U&/g' - вторая часть команды производит замену всех найденых маленьких латинских символов на большие
				s ключ s обозначает что будет производиться замена.
				/[a-z]/ - будет производиться поиск всех символов от латинского символа 'a' до латинкого символа 'z'
				/\U&/ - будет произведена замена найденого вхождения на большой символ (\U - заменит найденный символ на большой, & - заменяется на всю найденную строку)
				g - данный ключ указывает что замена будет произведена глобально по всей строке, то есть все найденные вхождения будут заменены.
			> "$2" - вывод будет перенаправлен в файл с именем указанным вторым аргументом командной строки
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2. Создать однострочный скрипт, который создаст директории для нуьфескольких годов (2010–2017), в них — поддиректории для месяцев (от 01 до 12), и в каждый из них запишет несколько файлов с произвольными записями. Например, 001.txt, содержащий текст «Файл 001», 002.txt с текстом «Файл 002» и т. д.20
	Как и в предыдущем задании создаю файл в котором будет размещен скрипт, делаю разрешение на запуск файла для всех пользователей.
	Запускаю скрипт из теущей директории (task02)
		./task2.sh

	Разбор скрипта:
*************************************************************
	task2.sh
*************************************************************
	#!/bin/bash
	for file in ./{2010..2017}/{01..12}/{001..003};
	do
		mkdir -p "S(dirname $file)" && echo file $(echo $file | cut -d '/' -f 5)" > "$file.txt"
	done
*************************************************************
	создаю цикл
		for file in ./{2010..2017}/{01..12}/{001..003};
	который будет перебирать все значения в списках (./{2010..2017}/{01..12}/{001..003}). В результате такой конструкции переменной file при каждой итерации будут присвоены переборы из списков.
	Пример:
		./2010/01/001
		./2010/01/002
		./2010/01/003
		...
		./2017/12/003
	количество итераций будет равно общему количеству создаваемых файлов.
	команды выполняемые во время итераций заключены между do  и done:
		do
			mkdir -p "$(dirname $file)" && echo "File $(echo $file | cut -d '/' -f 4)" > "$file.txt"
		done
	
	mkdir -p "$(dirname $file)" && echo "File $(echo $file | cut -d '/' -f 4)" > "$file.txt"
	
		mkdir -p "$(dirname $file)"
			mkdir - создает каталог
			-p - указывает на то что будут создаваться директории которые указаны в нутри пути. Если директория существует, предупреждение не будет выводиться.
			"$(dirname $file)" - данный параметр определяет имя создаваемого каталога
				$() - позволяет выполнить команду расположенную в скобках
				dirname $file - команде dirname передается переменная file. Данная команда выделяет путь каталогов от имени файла. Таким образом команде mкdir в качестве параметра будут передаваться только имя создаваемого каталога с относительным путем при каждой итерации.
			&& - указывает что помимо первой части команды в итерации будет выполнена И вторая часть команды.
			echo "File $(echo $file | cut -d'/' -f5)"
				echo "" - Здесь команда echo выводит в стандартный поток вывода то что содержиться в кавычках
				"File $(echo $file | cut -d'/' -f5)" - здесь формируется текст который будет выведен в стандартный поток вывода и далее будет записан в файл
					File - это символьный текст который должен быть записан в файл
					$(echo $file | cut -d'/' -f5) - в скобках формируется команда которая должна будет выполнена. данная команда формирует номер файла который будет добавлен к тексту при выводе в файл
						echo $file - выводит значение из переменной file которая содержит полный путь к создаваемому файлу
						cut -d'/' -f4 - вырезает все столбцы до 4 в котором остается номер файла
							-d'/' - устанавливает разделитель столбцов
							-f4 - определят столбец по который будет все вырезано
			> "$file.txt" - созданная ранее строка будет перенаправлена в файл с именем расположением указанным в переменной file. После переменной добавляется расширение .txt				


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
3. * Использовать команду AWK на вывод длинного списка каталога, чтобы отобразить только права доступа к файлам. Затем отправить в конвейере этот вывод на sort и uniq, чтобы отфильтровать все повторяющиеся строки.
	Для вывода списка каталога на экран выберу каталог /etc так как он содержит много файлов и каталогов.

	ls -la /etc | awk '{ print $1 }' | sort | uniq -с
	
	разбор команды:
		ls -la /etc - выводит список каталогов вместе со скрытыми файлами (ключ a) и в широком формате (ключ l) на стандартный поток вывода
		| awk '{ print $1 }' - выводит в станадртный поток вывода только первый столбец (print $1) данных переданных через пайп предыдущей команды
		| sort - производит сортировку 
		| uniq -с - удаляет повторяющиеся строки, ключ -с выводит информацию о количестве одинаковых строк.
	
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
4. Используя grep, проанализировать файл /var/log/syslog, отобрав события на своё усмотрение.
	
	cat /var/log/syslog | grep daemon
	cat /var/log/syslog | grep update
	cat /var/log/syslog | grep Starting

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
5. Создать разовое задание на перезагрузку операционной системы, используя at.
	sudo at 12:19  - вызываю команду at с правами root и в параметре указываю время 
	>sudo reboot  - ввожу команду которая должна будет выполнена. 
	>             - ctrl+d - завершаю работу утилиты at

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
6. * Написать скрипт, делающий архивную копию каталога etc, и прописать задание в crontab.
	rsybc -avz /etc backup
	

